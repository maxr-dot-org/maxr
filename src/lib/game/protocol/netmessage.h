/***************************************************************************
*      Mechanized Assault and Exploration Reloaded Projectfile            *
*                                                                         *
*   This program is free software; you can redistribute it and/or modify  *
*   it under the terms of the GNU General Public License as published by  *
*   the Free Software Foundation; either version 2 of the License, or     *
*   (at your option) any later version.                                   *
*                                                                         *
*   This program is distributed in the hope that it will be useful,       *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
*   GNU General Public License for more details.                          *
*                                                                         *
*   You should have received a copy of the GNU General Public License     *
*   along with this program; if not, write to the                         *
*   Free Software Foundation, Inc.,                                       *
*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
***************************************************************************/

#ifndef protocol_netmessageH
#define protocol_netmessageH

#include "game/data/freezemode.h"
#include "game/data/gui/playerguiinfo.h"
#include "game/data/player/playerbasicdata.h"
#include "game/data/report/savedreport.h"
#include "game/logic/gametimer.h"
#include "utility/color.h"
#include "utility/serialization/binaryarchive.h"
#include "utility/serialization/jsonarchive.h"
#include "utility/serialization/serialization.h"

#include <memory>

class cSavedReport;
class cSocket;

// When changing this enum, also update sEnumStringMapping<eNetMessageType>::m
enum class eNetMessageType
{
	/** TCP messages generated by the connection manager:
	    Note: do not change the numerical values of the first 3 message, to make sure the game
		version check is working across different maxr versions */
	TCP_HELLO = 0, /** sent from host to provide game version of the server (1st stage of the initial handshake) */
	TCP_WANT_CONNECT = 1, /** sent from client to provide credentials (2nd stage of the initial handshake) */
	TCP_CONNECTED = 2, /** sent from host, when the connection is accepted (3rd stage of the initial handshake) */
	TCP_CONNECT_FAILED, /** local event, when server is not reachable. Sent from host, if connection is declined by host */
	TCP_CLOSE, /** local event (generated by connection manager) to indicate a closed connection */

	MULTIPLAYER_LOBBY, /** messages for multiplayer lobby and game preparation menus */
	ACTION, /** the set of actions a client (AI or player) can trigger to influence the game */
	GAMETIME_SYNC_SERVER, /** sync message from server to clients */
	GAMETIME_SYNC_CLIENT, /** sync message from client to server */
	RANDOM_SEED, /** initialize the synchronized random generator of the models */
	FREEZE_MODES, /** Is the game running? And if it isn't, why not? */
	REPORT, /** chat messages and other reports for the player */
	GUI_SAVE_INFO, /** saved reports and gui settings */
	REQUEST_GUI_SAVE_INFO, /** requests the clients to send their gui data for saving */
	RESYNC_MODEL, /** transfer a copy of the complete modeldata to clients */
	REQUEST_RESYNC_MODEL, /** instructs the server to send a copy of the model */
	GAME_ALREADY_RUNNING, /** send by server, when a new connection is established, after the game has started */
	WANT_REJOIN_GAME, /** send by a client to reconnect a disconnected player */
};
namespace serialization
{
	template <>
	struct sEnumStringMapping<eNetMessageType>
	{
		static const std::vector<std::pair<eNetMessageType, const char*>> m;
	};
} // namespace serialization
//------------------------------------------------------------------------------
class cNetMessage
{
public:
	static std::unique_ptr<cNetMessage> createFromBuffer (const unsigned char* data, int length);

	virtual ~cNetMessage() {}

	eNetMessageType getType() const { return type; }
	std::unique_ptr<cNetMessage> clone() const;

	virtual void serialize (cBinaryArchiveOut& archive) { serializeThis (archive); }
	virtual void serialize (cJsonArchiveOut& archive) { serializeThis (archive); }

	cNetMessage& From (int player)
	{
		playerNr = player;
		return *this;
	}

	int playerNr = -1;

protected:
	explicit cNetMessage (eNetMessageType type) :
		type (type) {}

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (type);
		archive & NVP (playerNr);
		// clang-format on
	}

	eNetMessageType type;
};

//------------------------------------------------------------------------------
template <eNetMessageType MsgType>
class cNetMessageT : public cNetMessage
{
public:
	cNetMessageT() :
		cNetMessage (MsgType) {}
};

/**
* Interface called each time a message should be handled.
*/
class INetMessageHandler
{
public:
	virtual ~INetMessageHandler() = default;
	/**
	 * potentially handle the message
	 * @return if message is handled
	 */
	virtual bool handleMessage (const cNetMessage&) = 0;
};

//------------------------------------------------------------------------------
class cNetMessageTcpHello : public cNetMessageT<eNetMessageType::TCP_HELLO>
{
public:
	cNetMessageTcpHello();
	explicit cNetMessageTcpHello (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	std::string packageVersion;
	std::string packageRev;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (packageVersion);
		archive & NVP (packageRev);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageTcpWantConnect : public cNetMessageT<eNetMessageType::TCP_WANT_CONNECT>
{
public:
	cNetMessageTcpWantConnect();
	explicit cNetMessageTcpWantConnect (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	sPlayerSettings player;
	bool ready = false;
	std::string packageVersion;
	std::string packageRev;

	const cSocket* socket = nullptr;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (player);
		archive & NVP (ready);
		archive & NVP (packageVersion);
		archive & NVP (packageRev);
		// clang-format on
		// socket is not serialized
	}
};

//------------------------------------------------------------------------------
class cNetMessageTcpConnected : public cNetMessageT<eNetMessageType::TCP_CONNECTED>
{
public:
	explicit cNetMessageTcpConnected (int playerNr);
	explicit cNetMessageTcpConnected (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	std::string packageVersion;
	std::string packageRev;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (packageVersion);
		archive & NVP (packageRev);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
enum class eDeclineConnectionReason;

//------------------------------------------------------------------------------
class cNetMessageTcpConnectFailed : public cNetMessageT<eNetMessageType::TCP_CONNECT_FAILED>
{
public:
	explicit cNetMessageTcpConnectFailed (eDeclineConnectionReason reason) :
		reason (reason)
	{}
	explicit cNetMessageTcpConnectFailed (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	eDeclineConnectionReason reason;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (reason);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageTcpClose : public cNetMessageT<eNetMessageType::TCP_CLOSE>
{
public:
	explicit cNetMessageTcpClose (int playerNr_)
	{
		playerNr = playerNr_;
	}
};

//------------------------------------------------------------------------------
class cNetMessageSyncServer : public cNetMessageT<eNetMessageType::GAMETIME_SYNC_SERVER>
{
public:
	cNetMessageSyncServer() = default;
	explicit cNetMessageSyncServer (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	unsigned int gameTime = 0;
	unsigned int checksum = 0;
	unsigned int ping = 0;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (gameTime);
		archive & NVP (checksum);
		archive & NVP (ping);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageSyncClient : public cNetMessageT<eNetMessageType::GAMETIME_SYNC_CLIENT>
{
public:
	cNetMessageSyncClient() = default;
	explicit cNetMessageSyncClient (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	unsigned int gameTime = 0;

	//send debug data to server
	bool crcOK = false;
	unsigned int timeBuffer = 0;
	unsigned int ticksPerFrame = 0;
	unsigned int queueSize = 0;
	unsigned int eventCounter = 0;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (gameTime);
		archive & NVP (crcOK);
		archive & NVP (timeBuffer);
		archive & NVP (ticksPerFrame);
		archive & NVP (queueSize);
		archive & NVP (eventCounter);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageRandomSeed : public cNetMessageT<eNetMessageType::RANDOM_SEED>
{
public:
	explicit cNetMessageRandomSeed (uint64_t seed) :
		seed (seed) {}
	explicit cNetMessageRandomSeed (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	uint64_t seed;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (seed);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageFreezeModes : public cNetMessageT<eNetMessageType::FREEZE_MODES>
{
public:
	cNetMessageFreezeModes (const cFreezeModes& freezeModes, std::map<int, ePlayerConnectionState> playerStates) :
		freezeModes (freezeModes),
		playerStates (playerStates)
	{}
	explicit cNetMessageFreezeModes (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	cFreezeModes freezeModes;
	std::map<int, ePlayerConnectionState> playerStates;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (freezeModes);
		archive & NVP (playerStates);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageReport : public cNetMessageT<eNetMessageType::REPORT>
{
public:
	cNetMessageReport() = default;
	explicit cNetMessageReport (std::unique_ptr<cSavedReport> report) :
		report (std::move (report))
	{}

	explicit cNetMessageReport (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	std::unique_ptr<cSavedReport> report;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (report);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageGUISaveInfo : public cNetMessageT<eNetMessageType::GUI_SAVE_INFO>
{
public:
	cNetMessageGUISaveInfo (int slot, int savingID) :
		slot (slot),
		savingID (savingID)
	{}
	explicit cNetMessageGUISaveInfo (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	sPlayerGuiInfo guiInfo;
	int slot;
	int savingID;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (slot);
		archive & NVP (savingID);
		archive & NVP (guiInfo);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageRequestGUISaveInfo : public cNetMessageT<eNetMessageType::REQUEST_GUI_SAVE_INFO>
{
public:
	cNetMessageRequestGUISaveInfo (int slot, int savingID) :
		slot (slot),
		savingID (savingID)
	{}
	explicit cNetMessageRequestGUISaveInfo (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	int slot;
	int savingID;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (slot);
		archive & NVP (savingID);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageResyncModel : public cNetMessageT<eNetMessageType::RESYNC_MODEL>
{
public:
	explicit cNetMessageResyncModel (const cModel& model);
	explicit cNetMessageResyncModel (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}
	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	void apply (cModel& model) const;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (data);
		// clang-format on
	}

	std::vector<uint8_t> data;
};

//------------------------------------------------------------------------------
class cNetMessageRequestResync : public cNetMessageT<eNetMessageType::REQUEST_RESYNC_MODEL>
{
public:
	explicit cNetMessageRequestResync (int playerToSync = -1, int saveNumberForGuiInfo = -1) :
		playerToSync (playerToSync),
		saveNumberForGuiInfo (saveNumberForGuiInfo)
	{}
	explicit cNetMessageRequestResync (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	int playerToSync; // playerNr who will receive the data. -1 for all connected players
	int saveNumberForGuiInfo; // number of save game file, from which gui info will be loaded. -1 disables loading gui data

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (playerToSync);
		archive & NVP (saveNumberForGuiInfo);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageGameAlreadyRunning : public cNetMessageT<eNetMessageType::GAME_ALREADY_RUNNING>
{
public:
	explicit cNetMessageGameAlreadyRunning (const cModel& model);
	explicit cNetMessageGameAlreadyRunning (cBinaryArchiveIn& archive)
	{
		serializeThis (archive);
	}

	void serialize (cBinaryArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}
	void serialize (cJsonArchiveOut& archive) override
	{
		cNetMessage::serialize (archive);
		serializeThis (archive);
	}

	std::filesystem::path mapFilename;
	uint32_t mapCrc;
	std::vector<cPlayerBasicData> playerList;

private:
	template <typename Archive>
	void serializeThis (Archive& archive)
	{
		// clang-format off
		// See https://github.com/llvm/llvm-project/issues/44312
		archive & NVP (mapFilename);
		archive & NVP (mapCrc);
		archive & NVP (playerList);
		// clang-format on
	}
};

//------------------------------------------------------------------------------
class cNetMessageWantRejoinGame : public cNetMessageT<eNetMessageType::WANT_REJOIN_GAME>
{
public:
	cNetMessageWantRejoinGame() = default;
	explicit cNetMessageWantRejoinGame (cBinaryArchiveIn&)
	{}
};

#endif
